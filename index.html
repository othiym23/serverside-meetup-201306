<!doctype html>
<html lang="en">

<head>
<meta charset="utf-8">

<title>Working close to the core.</title>

<meta name="description" content="How to write Node tools that won't break in a month.">
<meta name="author" content="Forrest Lehwalder Norvell">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<link rel="stylesheet" href="css/reveal.min.css">
<link rel="stylesheet" href="css/theme/moon.css" id="theme">

<!-- For syntax highlighting -->
<link rel="stylesheet" href="lib/css/solarized-dark.css">

<!-- If the query includes 'print-pdf', use the PDF print sheet -->
<script>
document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
</script>

<!--[if lt IE 9]>
                <script src="lib/js/html5shiv.js"></script>
                <![endif]-->
</head>

<body>

<div class="reveal">

  <!-- Any section element inside of this container is displayed as a slide -->
  <div class="slides">

    <section>
      <h1>Working close to the core</h1>
      <h3>solve bigger problems with Node.js</h3>
      <p><small><a href="http://twitter.com/othiym23">Forrest L Norvell</a> (tw / gh: othiym23),
        <a href="http://newrelic.com">New Relic</a></small></p>
      <p><a href="http://is.gd/nodepdx2013">http://is.gd/nodepdx2013</a></p>
    </section>

    <section>
      <h2>Who / What / Why</h2>

      <p>Spent the last year writing a language agent for New Relic in Node.js</p>

      <p>&nbsp;</p>

      <p class="fragment"><br/>New Relic's job is not to tell you how to write your code.
      Our job is to give you the tools you need to figure out how to improve
      your code yourself.</p>

      <p>&nbsp;</p>

      <p class="fragment">Working with Node on its level is hard but fun. Let me help make
      it easier for you.</p>
    </section>

    <section>
      <h1>THE GOAL:</h1>
      <h3>Solve bigger problems with Node.</h3>
    </section>

    <section>
      <section>
        <h1>THE PROBLEM: COMPLEXITY IS YOUR ENEMY</h1>

        <aside class="notes">
          JavaScript's mongrel pedigree fosters complexity and cleverness to deal with
          the hard tradeoffs it imposes. Keep it simple.
        </aside>
      </section>

      <section>
        <h1>COMPLEXITY:</h1>
        <h3>JavaScript is neither FP nor OO.</h3>

        <ul>
          <li>It's kind of both:</li>
          <li>It is <i>possible</i> to use fundamental functional programming
          techniques in JavaScript.</li>
          <li>It is <i>possible</i> to use inheritance and simulate classes in
          JavaScript.</li>
          <li>In JavaScript, clarity and effectiveness are always in tension.</li>
        </ul>

        <aside class="notes">
          1. monads and lenses
          2. CoffeeScript provides a simulation of classes as transpiled sugar.
        </aside>
      </section>

      <section>
        <h1>COMPLEXITY:</h1>
        <h3>V8 is neither an interpreter nor a compiler</h3>

        <ul>
          <li>JavaScript, being dynamic, has no type system safety net.</li>
          <li>Closures can prevent JIT optimization.</li>
        </ul>
      </section>

      <section>
        <h1>COMPLEXITY:</h1>
        <h2>Writing tooling is a special challenge</h2>

        <ul>
          <li>Absolutely can't break anything.</li>
          <li>Almost as importantly, can't <i>change</i> anything.</li>
          <li>Needs to be as simple as possible without compromising performance.</li>
          <li>Lots of great tools and modules that app developers can use aren't available
          to developers writing instrumentation.</li>
        </ul>
      </section>

      <section>
        <h2>Prerequisites for Working with Node core</h2>

        <ul>
          <li>Learn how V8 works: <a href="http://mrale.ph/">mrale.ph</a>
          and <a href="http://wingolog.org">wingolog.org</a> are your guides.</li>
          <li>Learn to use <code>node debug</code> or <code>node-inspector</code>.
          <li>Spend some time with <code>src/node.js</code>, <code>src/node.cc</code>,
          and <code>lib/*</code>.
          <li><i>Don't</i> use Node's source as a model. Tuned for performance, not for
          simplicity.</li>
        </ul>
      </section>
    </section>

    <section>
      <h1>THE SOLUTION:</h1>
      <h2>keep it simple &amp; stupid</h2>

      <aside class="notes">
        <p>I really like Rich Hickey. The Clojure philosophy is less about
        programming language theory and more about clear and thoughtful
        design.</p>

        <p>Find the smallest, simplest, most internally orthogonal subset of
        JavaScript that works for you, and stick to it. Strive to be fluent in
        JavaScript. As with any language, fluency means you need to *think* and
        *design* in JavaScript. Let go of Ruby, C, Java -- whatever. Stop
        mentally translating from other languages into JavaScript. Your
        productivity is valuable, but evaluate productivity over months instead
        of days.</p>
      </aside>
    </section>

    <section>
      <section>
        <h2>digging down:</h2>
        <h3>think less, measure more</h3>

        <ul>
          <li>Testing and benchmarking framework included with Node's source.</li>
        </ul>
      </section>

      <section>
        <h2>digging down:</h2>
        <h3>refer to the source</h3>
      </section>

      <section>
        <h2>digging down:</h2>
        <h3>node debug vs console.log()</h3>
      </section>
    </section>

    <section>
      <section>
        <h2>building up:</h2>
        <h3>use Node's core abstractions</h3>

        <ul>
          <li>EventEmitters</li>
          <li>streams -- <code>in.pipe(out)</code> if nothing else</li>
          <li>modules</li>
        </ul>
      </section>

      <section>
        <h2>building up:</h2>
        <h3>use the whole ES5 toolbox</h3>

        <ul>
          <li><code>'use strict';</code></li>
          <li>jshint</li>
          <li><code>forEach</code>, <code>map</code>, and <code>reduce</code>
          are built into Array.</li>
          <li><code>Object.keys()</code> is a simple way to enumerate object properties.</li>
          <li><code>Function.bind()</code> is a cleaner way of capturing <code>this</code></li>
        </ul>

        <p><i>remember: ES6 is not real yet</i></p>
      </section>
    </section>

    <section>
      <section>
        <h2>building up:</h2>
        <h3>metaprogramming vs monkeypatching</h3>
      </section>

      <section>
        <h2>Don't try to metaprogram in JavaScript</h2>

        <ul>
          <li>Magic is bad.</li>
          <li>Magic is super fun.</li>
          <li>Metaprogramming is magic.</li>
          <li class="fragment"><strike>Therefore, metaprogramming is super
          fun.</strike></li>
          <li class="fragment">Therefore, metaprogramming is bad.</li>
        </ul>
      </section>

      <section>
        <h2>How not to metaprogram in JavaScript</h2>

        <ul>
          <li>Leave req and res alone: prefer composition to extension.</li>
          <li><code>Object.defineProperty()</code> and friends can be
          confusing and slow.</li>
          <li>Don't control flow via function arity.</li>
        </ul>

        <aside class="notes">
          <p>JavaScript doesn't have method overriding or multimethod dispatch,
          and simulating that by dispatching on the number of parameters is
          surprising and difficult to monkeypatch correctly.</p>
          <p>modifying the behavior of built-in objects increases the risk of
          breaking on new releases or when using others' modules.</p>
        </aside>
      </section>

      <section>
        <h1>Monkeypatching</h1>

        <pre><code class="javascript" data-trim>
var http = require('http');
var _request = http.request;
http.request = function () {
  console.log("requestin'");
  return _request.apply(this, arguments);
};
        </code></pre>
      </section>

      <section>
        <h2>Monkeypatch safely</h2>

        <p>Fail via early return rather than throwing:</p>
        <pre><code class="javascript" data-trim>
function wrap(nodule, name, wrapper) {
  if (!nodule || !nodule[name] || !wrapper) return;
  // other stuff
}
        </code></pre>
      </section>

      <section>
        <h2>Monkeypatch safely</h2>

        <p>Log everything:</p>
        <pre><code class="javascript" data-trim>
var logger = require('logger');
function wrap(nodule, name, wrapper) {
  logger.debug("Attempting to wrap %s.%s", nodule, name);
  if (!nodule || !nodule[name]) {
    logger.warn("no function to wrap provided");
    return;
  }
  if (!wrapper) {
    logger.warn("no wrapper function provided");
    return;
  }
  // other stuff
}
        </code></pre>
      </section>

      <section>
        <h2>Monkeypatch safely</h2>

        <p>Leave visible traces:</p>
        <pre><code class="javascript" data-trim>
function wrap(nodule, name, wrapper) {
  // setup
  var wrapped = wrapper(nodule[name]);
  wrapped.__WRAPPED = "yo dawg";

  nodule[name] = wrapped;
}
        </code></pre>
      </section>

      <section>
        <h2>Monkeypatch safely</h2>

        <p>Wrap and unwrap idempotently:</p>
        <pre><code class="javascript" data-trim>
function wrap(nodule, name, wrapper) {
  // other setup
  if (nodule[name].__WRAPPED) return;
  var original = nodule[name];

  var wrapped = wrapper(original);
  wrapped.__WRAPPED = "yo dawg";
  wrapped.__UNWRAP = function () {
    nodule[name] = original;
  };

  nodule[name] = wrapped;
}

function unwrap(method) {
  if (method.__UNWRAP) method.__UNWRAP();
}
        </code></pre>
      </section>

      <section>
        <h2>Monkeypatch safely</h2>

        <p>Always return the results of wrapped calls:</p>
        <pre><code class="javascript" data-trim>
function wrapper(original) {
  return function () {
    console.log("yo dawg: before");

    var returned = original.apply(this, arguments); // XXX

    console.log("yo dawg: the dawggening");

    return returned;
  };
}
        </code></pre>
      </section>
    </section>

    <section>
      <section>
        <h2>building up:</h2>
        <h3>handle errors one way</h3>

        <ul>
          <li>Domains are imperative and optimized in Node. I like them.</li>
        </ul>
      </section>

      <section>
        <h2>your friends, domains</h2>

        <p><small>A whole other topic: <a href="http://is.gd/domainion">http://is.gd/domainion</a>.</small></p>

        <ul>
          <li>allow you to layer error handling</li>
          <li><code>domain.bind()</code> and <code>domain.intercept()</code> allow
          you to pull all error handling into domains</li>
          <li>Domains can be used for problems aside from error-handling...</li>
          <li class="fragment">...but that's not what they're good at.</li>
        </ul>
      </section>
    </section>

    <section>
      <h2>building up:</h2>
      <h3>use one strategy for control flow</h3>

      <p>raw events / streams, <code>async</code>, a promises library, TameJS,
      <code>streamline</code>, fibers, monads, <code>reducers</code>, Iced
      CoffeeScript, something you wrote yourself...</p>
      <p><i>...just pick one per project and stick with it.</i></p>
      <p class="fragment">also, can we please stop arguing about this now?</p>
    </section>

    <section>
      <h3>In conclusion</h3>

      <p>Keep it simple, keep it safe.</p>
      <p>&nbsp;</p>
      <img width=476
           height=142
           src="http://25.media.tumblr.com/tumblr_m87bsc0tU61r9onvzo2_r1_500.gif"
           alt="Gandalf says keep it safe"/>
      <p>&nbsp;</p>
      <p><a href="http://is.gd/domainion">http://is.gd/domainion</a></p>
      <p><a href="http://twitter.com/othiym23">http://twitter.com/othiym23</a> /
         <a href="http://github.com/othiym23">http://github.com/othiym23</a></p>
      <p><a href="http://npmjs.org/package/newrelic">http://npmjs.org/package/newrelic</a></p>
      <p><a href="http://newrelic.com/">http://newrelic.com/</a> <small>(we're <a href="https://newrelic.com/about/jobs">hiring</a>)</small></p>
      <p><big><a href="http://is.gd/nodepdx2013">http://is.gd/nodepdx2013</a></big></p>
    </section>
  </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>

<script>

// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
  controls: true,
  progress: true,
  history: true,
  center: true,

  theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
  transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

  // Optional libraries used to extend on reveal.js
  dependencies: [
    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
    // { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
    // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
});

</script>

</body>
</html>
