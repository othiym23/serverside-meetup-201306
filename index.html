<!doctype html>
<html lang="en">

<head>
<meta charset="utf-8">

<title>Working close to the metal.</title>

<meta name="description" content="How to write Node tools that won't break in a month.">
<meta name="author" content="Forrest Lehwalder Norvell">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<link rel="stylesheet" href="css/reveal.min.css">
<link rel="stylesheet" href="css/theme/moon.css" id="theme">

<!-- For syntax highlighting -->
<link rel="stylesheet" href="lib/css/solarized-dark.css">

<!-- If the query includes 'print-pdf', use the PDF print sheet -->
<script>
document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
</script>

<!--[if lt IE 9]>
                <script src="lib/js/html5shiv.js"></script>
                <![endif]-->
</head>

<body>

<div class="reveal">

  <!-- Any section element inside of this container is displayed as a slide -->
  <div class="slides">

    <section>
      <h1>Working close to the metal</h1>
      <h3>writing durable code with Node.js</h3>
      <p><small><a href="http://twitter.com/othiym23">Forrest L Norvell</a> (tw / gh: othiym23),
        <a href="http://newrelic.com">New Relic</a></small></p>
      <p><a href="http://is.gd/serverside_2013_06">http://is.gd/serverside_2013_06</a></p>
    </section>

    <section>
      <h2>Who / What / Why</h2>

      <p>Spent the last year writing a Node.js language agent for New Relic.</p>

      <p>&nbsp;</p>

      <p class="fragment"><br/>New Relic's job is not to tell you how to write
      your code.  Our job is to give you the tools you need to figure out how
      to improve your code yourself.</p>

      <p>&nbsp;</p>

      <p class="fragment">You gotta be crafty to write fast, maintainable
      server-side JavaScript. Getting good at it is more a matter of attitude
      than specific techniques, but here's some of both.</p>
    </section>

    <section>
      <h1>THE GOAL:</h1>
      <h3>Solve bigger problems with Node.</h3>
    </section>

    <section>
      <section>
        <h1>THE PROBLEM: COMPLEXITY IS YOUR ENEMY</h1>

        <aside class="notes">
          JavaScript's mongrel pedigree fosters complexity and cleverness to deal with
          the hard tradeoffs it imposes. Keep it simple.
        </aside>
      </section>

      <section>
        <h2>COMPLEXITY:</h2>
        <h3>JavaScript is neither FP nor OO. It's kind of both.</h3>

        <ul>
          <li>It is <i>possible</i> to use fundamental functional programming
          techniques in JavaScript.</li>
          <li>It is <i>possible</i> to use inheritance and simulate classes in
          JavaScript.</li>
          <li>It's often <i>better</i> to write imperative, procedural code.
        </ul>

        <p>&nbsp;</p>

        <p><i>In JavaScript, clarity and effectiveness are always in tension.</i></p>

        <aside class="notes">
          1. monads and lenses
          2. CoffeeScript provides a simulation of classes as transpiled sugar.
        </aside>
      </section>

      <section>
        <h2>COMPLEXITY:</h2>
        <h3>V8 is neither an interpreter nor a compiler. It's kind of both.</h3>

        <ul>
          <li>JavaScript, being dynamic, has no type system safety net.</li>
          <li>Closures can prevent JIT optimization.</li>
          <li><a href="http://mrale.ph/">Slava Egorov</a> (http://mrale.ph) and
          <a href="http://wingolog.org">Andy Wingo</a> (http://wingolog.org) can
          demystify the black box that is V8's JIT.</li>
        </ul>
      </section>

      <section>
        <h2>COMPLEXITY:</h2>
        <h3>Writing tooling is a special challenge</h3>

        <ul>
          <li>Absolutely can't break anything.</li>
          <li>Almost as importantly, can't <i>change</i> anything.</li>
          <li>Needs to be as simple as possible without compromising performance.</li>
          <li>Lots of great tools and modules that app developers can use aren't available
          to developers writing instrumentation.</li>
        </ul>
      </section>
    </section>

    <section>
      <h1>THE SOLUTION:</h1>
      <h2>keep it simple &amp; stupid</h2>

      <aside class="notes">
        <p>I really like Rich Hickey. The Clojure philosophy is less about
        programming language theory and more about clear and thoughtful
        design.</p>

        <p>Find the smallest, simplest, most internally orthogonal subset of
        JavaScript that works for you, and stick to it. Strive to be fluent in
        JavaScript. As with any language, fluency means you need to *think* and
        *design* in JavaScript. Let go of Ruby, C, Java -- whatever. Stop
        mentally translating from other languages into JavaScript. Your
        productivity is valuable, but evaluate productivity over months instead
        of days.</p>
      </aside>
    </section>

    <section>
      <section>
        <h2>digging down:</h2>
        <h3>think less, measure more</h3>

        <pre><code class="javascript" data-trim>
function verify(input, nonce) {
  var hashed = new Hash('sha256').update(input).update(nonce).digest('hex');
  if (hashed.substr(62, 2) === '00') return hashed;
}
        </code></pre>

        <ul>
          <li>Don't measure abstractions: measure for <i>your</i> problem under <i>your</i> workload.</li>
          <li>Node's source includes a pretty good framework for benchmarking.</li>
        </ul>
      </section>

      <section>
        <h2>digging down:</h2>
        <h3>refer to the source</h3>

        <ul>
          <li>Spend some time with <code>src/node.js</code>, <code>src/node.cc</code>, and <code>lib/*</code>.
          <li><i>Don't</i> use Node's source as a model. Tuned for performance, not for simplicity.</li>
        </ul>
      </section>

      <section>
        <h2>digging down:</h2>
        <h3>node debug vs console.log()</h3>

        <ul>
          <li><code>node debug</code> or <code>node-inspector</code></li>
          <li><code>node debug</code> is harder to learn but faster to use.</li>
          <li><code>kill -USR1 &lt;pid&gt; &amp;&amp; node debug localhost:5858</code></li>
        </ul>
      </section>
    </section>

    <section>
      <section>
        <h2>building up:</h2>
        <h3>use Node's core abstractions</h3>

        <ul>
          <li>EventEmitters</li>
          <li>streams -- <code>in.pipe(out)</code> if nothing else</li>
          <li>modules</li>
        </ul>
      </section>

      <section>
        <h2>building up:</h2>
        <h3>use the whole ES5 toolbox</h3>

        <ul>
          <li><code class="javascript">'use strict';</code> (backed up with <code>jshint</code> or <code>jslint</code>)</li>
          <li>Array builtins like <code>forEach</code>, <code>map</code>, and <code>reduce</code></li>
          <li><code class="javascript">Object.keys()</code> is a simple way to enumerate object properties</li>
          <li><code class="javascript">Function.bind()</code> is a cleaner way of capturing <code class="javascript">this</code></li>
        </ul>
      </section>

      <section>
        <h2>building up:</h2>
        <h3>metaprogramming vs monkeypatching</h3>

        <h4>Don't try to metaprogram in JavaScript</h4>

        <ul>
          <li>Magic is bad. Magic is super fun. Metaprogramming is magic.</li>
          <li class="fragment"><strike>&#8756; Metaprogramming is super fun.</strike></li>
          <li class="fragment"> &#8756; Metaprogramming is bad.</li>
        </ul>

        <ul class="fragment">
          <li>Leave <code>req</code> and <code>res</code> alone: prefer composition to extension.</li>
          <li><code>Object.defineProperty()</code> and friends can be confusing and slow.</li>
          <li>Don't control flow via function arity.</li>
        </ul>

        <aside class="notes">
          <p>JavaScript doesn't have method overriding or multimethod dispatch,
          and simulating that by dispatching on the number of parameters is
          surprising and difficult to monkeypatch correctly.</p>
          <p>modifying the behavior of built-in objects increases the risk of
          breaking on new releases or when using others' modules.</p>
        </aside>
      </section>
    </section>

    <section>
      <section>
        <h2>building up: monkeypatching</h2>

        <pre><code class="javascript" data-trim>
var http = require('http');
var _request = http.request;
http.request = function () {
  console.log("requestin'");
  return _request.apply(this, arguments);
};
        </code></pre>
      </section>

      <section>
        <h3>Monkeypatch safely</h3>

        <p>Fail via early return rather than throwing:</p>
        <pre><code class="javascript" data-trim>
function wrap(nodule, name, wrapper) {
  if (!nodule || !nodule[name] || !wrapper) return;
  // other stuff
}
        </code></pre>
      </section>

      <section>
        <h3>Monkeypatch safely</h3>

        <p>Log everything:</p>
        <pre><code class="javascript" data-trim>
var logger = require('logger');
function wrap(nodule, name, wrapper) {
  logger.debug("Attempting to wrap %s.%s", nodule, name);
  if (!nodule || !nodule[name]) {
    logger.warn("no function to wrap provided");
    return;
  }
  if (!wrapper) {
    logger.warn("no wrapper function provided");
    return;
  }
  // other stuff
}
        </code></pre>
      </section>

      <section>
        <h3>Monkeypatch safely</h3>

        <p>Leave visible traces:</p>
        <pre><code class="javascript" data-trim>
function wrap(nodule, name, wrapper) {
  // setup
  var wrapped = wrapper(nodule[name]);
  wrapped.__WRAPPED = "yo dawg";

  nodule[name] = wrapped;
}
        </code></pre>
      </section>

      <section>
        <h3>Monkeypatch safely</h3>

        <p>Wrap and unwrap idempotently:</p>
        <pre><code class="javascript" data-trim>
function wrap(nodule, name, wrapper) {
  // other setup
  if (nodule[name].__WRAPPED) return;
  var original = nodule[name];

  var wrapped = wrapper(original);
  wrapped.__WRAPPED = "yo dawg";
  wrapped.__UNWRAP = function () {
    nodule[name] = original;
  };

  nodule[name] = wrapped;
}

function unwrap(method) {
  if (method.__UNWRAP) method.__UNWRAP();
}
        </code></pre>
      </section>

      <section>
        <h3>Monkeypatch safely</h3>

        <p>Always return the results of wrapped calls:</p>
        <pre><code class="javascript" data-trim>
function wrapper(original) {
  return function () {
    console.log("yo dawg: before");

    var returned = original.apply(this, arguments); // XXX

    console.log("yo dawg: the dawggening");

    return returned;
  };
}
        </code></pre>
      </section>
    </section>

    <section>
      <section>
        <h2>building up:</h2>
        <h3>handle errors one way</h3>

        <p>Domains are fast and simple. I like them.</p>

        <ul>
          <li>allow you to layer error handling</li>
          <li><code>domain.bind()</code> and <code>domain.intercept()</code> allow you to unify error handling behind domains</li>
        </ul>
      </section>

      <section>
        <h2>building up:</h2>
        <h3>use one strategy for control flow</h3>

        <p>raw events / streams, <code>async</code>, a promises library, TameJS,
        <code>streamline</code>, fibers, monads, <code>reducers</code>, Iced
        CoffeeScript, something you wrote yourself...</p>
        <p><i>...just pick one per project and stick with it.</i></p>
        <p class="fragment">also, can we please stop arguing about this now?</p>
      </section>
    </section>

    <section>
      <h3>Questions &amp; conclusions</h3>

      <p>Thanks for listening.</p>
      <p>&nbsp;</p>
      <p><a href="http://twitter.com/othiym23">http://twitter.com/othiym23</a> /
         <a href="http://github.com/othiym23">http://github.com/othiym23</a></p>
      <p><a href="http://newrelic.com/">http://newrelic.com/</a> <small>(we're <a href="https://newrelic.com/about/jobs">hiring</a>)</small></p>
      <p><big><a href="http://is.gd/serverside_2013_06">http://is.gd/serverside_2013_06</a></big></p>
    </section>
  </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>

<script>

// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
  controls: true,
  progress: true,
  history: true,
  center: true,

  theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
  transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

  // Optional libraries used to extend on reveal.js
  dependencies: [
    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
    // { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
    // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
});

</script>

</body>
</html>
